# What is a Shader? 

## The Chef Analogy

A shader can be understood through a professional kitchen with specialized chefs:

- **The Kitchen** = The GPU (hardware where cooking happens)
- **The Recipe Book** = The shader program (instructions written in code)
- **The Head Chef** = The Vertex Shader (prepares ingredients)
- **The Sous Chef** = The Fragment Shader (plates the final dish)
- **The Ingredients** = Input data (vertices, textures, uniforms)
- **The Finished Dish** = The output pixel color

**A shader is a recipe that tells the GPU exactly how to cook each ingredient into the final image.**

---

## Part 1: What Actually IS a Shader?

### Definition

A **shader** is a small program that runs on the GPU (Graphics Processing Unit) that calculates rendering effects. Shaders execute in parallel for thousands of vertices or pixels simultaneously.

### Core Characteristics

| Characteristic | Description |
|----------------|-------------|
| **Program Type** | Small, focused programs (usually <1000 lines) |
| **Execution Location** | GPU (not CPU) |
| **Execution Model** | Massive parallelism (thousands of instances) |
| **Language** | GLSL (OpenGL Shading Language), HLSL, or SPIR-V |
| **Purpose** | Transform input data into visual output |
| **Lifespan** | Compiled and linked at runtime, persists on GPU |

### Key Insight

**Shaders are not called like functions.** They are installed on the GPU, and when a draw call executes, the GPU runs thousands of shader instances simultaneously on different data.

```
CPU SIDE:
glDrawArrays(GL_TRIANGLES, 0, 1000);  // Draw 1000 vertices

GPU SIDE AUTOMATICALLY:
Vertex Shader runs 1000 times (once per vertex)
    ↓
Fragment Shader runs millions of times (once per pixel)
```

---

## Part 2: Why Shaders Exist

### The Problem Before Shaders

Before programmable shaders (pre-2004), graphics were limited:

```cpp
// Fixed function era - what you see is what you get
glEnable(GL_LIGHTING);
glLightfv(GL_LIGHT0, GL_DIFFUSE, some_color);
// CANNOT create: toon shading, rim lighting, procedural textures
// CANNOT modify: per-pixel effects, custom blending
```

### What Shaders Enabled

| Before Shaders | After Shaders |
|----------------|---------------|
| Fixed lighting models | Any lighting model imaginable |
| Simple texture combos | Complex multi-texture effects |
| Per-vertex calculations | Per-pixel precision |
| Hardware-determined effects | Artist/developer-determined effects |
| Limited realism | Cinematic quality |

### The Revolution

Shaders transformed graphics from **configuration** to **programming**:

```
CONFIGURATION ERA:
"Here are my light settings. Here are my material settings. 
GPU, please render with your built-in formulas."

PROGRAMMING ERA:
"GPU, here is the exact mathematical formula I want you to use
for every pixel. If I want purple polka dots with animated 
rainbow lighting, I'll write the code for it."
```

---

## Part 3: Types of Shaders

### The Complete Shader Pipeline

```
VERTEX SHADER (Required)
    ↓ (Processed vertices)
TESSELLATION CONTROL SHADER (Optional)
    ↓ (Tessellation factors)
TESSELLATION EVALUATION SHADER (Optional)
    ↓ (Refined vertices)
GEOMETRY SHADER (Optional)
    ↓ (Primitives)
RASTERIZATION (Fixed Function - no shader)
    ↓ (Fragments)
FRAGMENT SHADER (Required)
    ↓ (Colored fragments)
COMPUTE SHADER (Separate, not in graphics pipeline)
```

### Shader Type Comparison

| Shader Type | Input | Output | Runs Per | Purpose |
|-------------|-------|--------|----------|---------|
| **Vertex** | Vertex attributes | Transformed vertex | Every vertex | Position, data prep |
| **Tessellation Control** | Patch vertices | Tessellation levels | Every patch | LOD control |
| **Tessellation Evaluation** | Tessellated coordinates | New vertices | Every new vertex | Smooth surfaces |
| **Geometry** | Primitive | Zero/more primitives | Every primitive | Amplify/cull |
| **Fragment** | Interpolated data | Color/depth | Every fragment | Pixel coloring |
| **Compute** | Arbitrary buffers | Arbitrary buffers | Work groups | General GPU compute |

---

## Part 4: Vertex Shader - The First Stage

### Purpose

Transform each vertex from 3D model space to screen space and prepare data for later stages.

### Input Sources

```
PER-VERTEX INPUT (Attributes):
├─ Position (vec3) - Where the vertex is
├─ Normal (vec3) - Which way the surface faces
├─ UV (vec2) - Texture coordinates
├─ Color (vec4) - Per-vertex color
└─ Tangent/Bitangent (vec3) - For normal mapping

GLOBAL INPUT (Uniforms):
├─ Model matrix - Object transformation
├─ View matrix - Camera position/orientation
├─ Projection matrix - 3D to 2D conversion
├─ Light positions - For lighting calculations
└─ Time - For animations
```

### Vertex Shader Code Example

```glsl
#version 330 core

// Input attributes (per vertex)
layout (location = 0) in vec3 aPos;      // Position
layout (location = 1) in vec3 aNormal;    // Normal
layout (location = 2) in vec2 aTexCoord;  // UV coordinates

// Uniforms (same for all vertices)
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
uniform float time;

// Outputs to fragment shader
out vec2 TexCoord;
out vec3 Normal;
out vec3 FragPos;
out float VertexTime;

void main()
{
    // Calculate world position
    vec4 worldPos = model * vec4(aPos, 1.0);
    FragPos = worldPos.xyz;
    
    // Calculate screen position
    gl_Position = projection * view * worldPos;
    
    // Pass through texture coordinate
    TexCoord = aTexCoord;
    
    // Transform normal to world space
    Normal = mat3(transpose(inverse(model))) * aNormal;
    
    // Pass time (could animate something)
    VertexTime = time + aPos.x;  // Different per vertex
}
```

### What Vertex Shader Cannot Do

- ❌ Create new vertices
- ❌ Destroy vertices
- ❌ Access other vertices' data
- ❌ Know which primitive it belongs to
- ❌ Write to framebuffer

---

## Part 5: Fragment Shader - The Final Stage

### Purpose

Calculate the final color of each pixel (fragment) after rasterization.

### Input Sources

```
INTERPOLATED INPUT (from vertex shader):
├─ UV coordinates - Smoothly varying across triangle
├─ Normal - Interpolated per pixel
├─ World position - Interpolated position
└─ Color - Interpolated vertex colors

UNIFORMS (global):
├─ Textures - Image data to sample
├─ Light information - Positions, colors
├─ Camera position - For view-dependent effects
└─ Material properties - Shininess, etc.

SYSTEM VALUES:
├─ gl_FragCoord - Screen position of pixel
├─ gl_FrontFacing - Is triangle front or back face?
└─ gl_PointCoord - For point sprites
```

### Fragment Shader Code Example

```glsl
#version 330 core

// Inputs from vertex shader (interpolated)
in vec2 TexCoord;
in vec3 Normal;
in vec3 FragPos;

// Uniforms
uniform sampler2D diffuseTexture;
uniform sampler2D specularTexture;
uniform vec3 lightPos;
uniform vec3 lightColor;
uniform vec3 viewPos;
uniform float time;

// Output
out vec4 FragColor;

void main()
{
    // Sample textures
    vec4 diffuseColor = texture(diffuseTexture, TexCoord);
    vec4 specularColor = texture(specularTexture, TexCoord);
    
    // Normalize interpolated values
    vec3 norm = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    vec3 viewDir = normalize(viewPos - FragPos);
    
    // Ambient lighting
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * lightColor;
    
    // Diffuse lighting
    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = diff * lightColor;
    
    // Specular lighting (Blinn-Phong)
    vec3 halfwayDir = normalize(lightDir + viewDir);
    float spec = pow(max(dot(norm, halfwayDir), 0.0), 32.0);
    vec3 specular = spec * specularColor.rgb * lightColor;
    
    // Combine with texture
    vec3 result = (ambient + diffuse + specular) * diffuseColor.rgb;
    
    // Add time-based effect (pulse)
    float pulse = sin(time * 2.0 + FragPos.x * 2.0) * 0.1 + 0.9;
    result *= pulse;
    
    // Output final color
    FragColor = vec4(result, diffuseColor.a);
    
    // Can also discard fragments
    if (diffuseColor.a < 0.1) {
        discard;  // Don't render transparent pixels
    }
}
```

### Fragment Shader Capabilities

| Operation | Example |
|-----------|---------|
| **Texture Sampling** | `texture(tex, uv)` |
| **Math Operations** | `sin, cos, pow, dot, cross` |
| **Conditional Logic** | `if, else, switch` |
| **Loops** | `for, while` (with limits) |
| **Discard** | `discard;` (kill fragment) |
| **Derivatives** | `dFdx, dFdy` (pixel neighbors) |

---

## Part 6: Shader Language Basics (GLSL)

### GLSL Data Types

| Type Category | Examples | Description |
|---------------|----------|-------------|
| **Scalars** | `float`, `int`, `uint`, `bool` | Single values |
| **Vectors** | `vec2`, `vec3`, `vec4` | 2-4 component vectors |
| **Matrices** | `mat2`, `mat3`, `mat4` | Square matrices |
| **Samplers** | `sampler2D`, `samplerCube` | Texture handles |
| **Arrays** | `float[5]`, `vec3[10]` | Fixed-size arrays |
| **Structs** | `struct Light { vec3 pos; vec3 color; }` | Custom types |

### Vector Swizzling

```glsl
vec4 position = vec4(1.0, 2.0, 3.0, 4.0);

float x = position.x;        // 1.0
float y = position.y;        // 2.0
vec2 xy = position.xy;       // (1.0, 2.0)
vec3 xyz = position.xyz;     // (1.0, 2.0, 3.0)
vec4 rgba = position.rgba;   // Same as xyzw
vec2 yx = position.yx;       // (2.0, 1.0) - Swizzled!
vec3 yyy = position.yyy;     // (2.0, 2.0, 2.0) - Replicated!
```

### Built-in Functions

| Category | Functions |
|----------|-----------|
| **Trigonometry** | `sin, cos, tan, asin, acos, atan` |
| **Exponential** | `pow, exp, log, sqrt, inversesqrt` |
| **Geometric** | `dot, cross, normalize, reflect, refract` |
| **Matrix** | `matrixCompMult, transpose, inverse` |
| **Vector Relational** | `lessThan, equal, any, all` |
| **Texture** | `texture, textureLod, textureProj` |
| **Derivatives** | `dFdx, dFdy, fwidth` |

---

## Part 7: Shader Execution Model

### Massive Parallelism

```
DRAW CALL: glDrawArrays(GL_TRIANGLES, 0, 3000)

GPU EXECUTION:
┌─────────────────────────────────────────────┐
│ VERTEX SHADER INSTANCES (3000 total)        │
├─────────────────────────────────────────────┤
│ Instance 0: Process vertex 0                │
│ Instance 1: Process vertex 1                │
│ Instance 2: Process vertex 2                │
│ ...                                         │
│ Instance 2999: Process vertex 2999          │
│ ALL EXECUTING SIMULTANEOUSLY!               │
└─────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────┐
│ FRAGMENT SHADER INSTANCES (2.1M for 1080p)  │
├─────────────────────────────────────────────┤
│ Instance 0: Process pixel (x,y)             │
│ Instance 1: Process pixel (x+1,y)           │
│ Instance 2: Process pixel (x+2,y)           │
│ ...                                         │
│ ALL EXECUTING SIMULTANEOUSLY!               │
└─────────────────────────────────────────────┘
```

### The SIMT Model

Shaders use **SIMT** (Single Instruction, Multiple Threads):

```
WARP (32 threads executing together):

All threads:   color = texture(tex, uv)      ✓ All active
All threads:   color *= lighting              ✓ All active

Threads 0-15:  if (condition) {              ✗ Divergence!
                    color = red                16 threads active
                } else {                        16 threads idle
                    color = blue                16 threads idle
                }                                16 threads active

All threads:   output = color + fog           ✓ All active
```

**Performance Implication:** Try to avoid branching where threads in the same warp take different paths.

---

## Part 8: Shader Input/Output Flow

### Complete Data Flow

```
CPU SIDE:
┌─────────────────────────────────────┐
│ Vertex Data (attributes)            │
│ └─ Position, Normal, UV, Color      │
│                                     │
│ Uniform Data (global)               │
│ └─ Matrices, Lights, Time, Textures │
└─────────────────────────────────────┘
              ↓ (glVertexAttribPointer)
              ↓ (glUniform)
GPU SIDE:
┌─────────────────────────────────────┐
│ VERTEX SHADER                       │
│ Input:  Attributes + Uniforms       │
│ Output: Varying variables           │
└─────────────────────────────────────┘
              ↓ (Interpolation)
┌─────────────────────────────────────┐
│ RASTERIZER (Fixed Function)         │
│ Interpolates varyings across pixels │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│ FRAGMENT SHADER                     │
│ Input:  Interpolated varyings       │
│         + Uniforms                  │
│ Output: Final color                 │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│ FRAMEBUFFER                         │
│ Final pixel colors ready for display│
└─────────────────────────────────────┘
```

### Varying Variables (In/Out)

```glsl
// Vertex Shader
#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec2 aTexCoord;

out vec2 vTexCoord;  // Output to fragment shader

void main()
{
    vTexCoord = aTexCoord;  // Set per vertex
    gl_Position = vec4(aPos, 1.0);
}

// Fragment Shader
#version 330 core
in vec2 vTexCoord;  // Input from vertex shader (interpolated!)
out vec4 FragColor;

uniform sampler2D ourTexture;

void main()
{
    // vTexCoord is now interpolated smoothly across the triangle
    FragColor = texture(ourTexture, vTexCoord);
}
```

---

## Part 9: Shader Compilation and Linking

### The Shader Pipeline in Code

```cpp
// 1. CREATE SHADER OBJECTS
GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);
GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);

// 2. PROVIDE SOURCE CODE
glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);
glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);

// 3. COMPILE SHADERS
glCompileShader(vertexShader);
glCompileShader(fragmentShader);

// 4. CHECK COMPILATION
int success;
char infoLog[512];
glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);
if (!success) {
    glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);
    std::cout << "Vertex shader compilation failed:\n" << infoLog << std::endl;
}

// 5. CREATE PROGRAM AND ATTACH SHADERS
GLuint shaderProgram = glCreateProgram();
glAttachShader(shaderProgram, vertexShader);
glAttachShader(shaderProgram, fragmentShader);

// 6. LINK PROGRAM
glLinkProgram(shaderProgram);

// 7. CHECK LINKING
glGetProgramiv(shaderProgram, GL_LINK_STATUS, &success);
if (!success) {
    glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);
    std::cout << "Shader linking failed:\n" << infoLog << std::endl;
}

// 8. USE THE PROGRAM
glUseProgram(shaderProgram);

// 9. CLEANUP (after linking)
glDeleteShader(vertexShader);
glDeleteShader(fragmentShader);
```

### Compilation Errors Example

```
Common errors beginners see:

ERROR: 0:12 '=' : cannot convert from 'float' to 'vec4'
    vec4 color = 1.0;  // Wrong - need vec4(1.0)

ERROR: 0:8 'texture' : no matching overloaded function found
    texture(tex, uv, 3);  // Wrong - too many arguments

ERROR: 0:5 'main' : function already has a body
    // Multiple main() functions
```

---

## Part 10: Uniforms - Global Shader Variables

### What Are Uniforms?

**Uniforms** are global variables set from the CPU that remain constant for an entire draw call.

### Setting Uniforms

```cpp
// In C++ code
glUseProgram(shaderProgram);

// Get uniform locations
GLint modelLoc = glGetUniformLocation(shaderProgram, "model");
GLint viewLoc = glGetUniformLocation(shaderProgram, "view");
GLint projLoc = glGetUniformLocation(shaderProgram, "projection");
GLint timeLoc = glGetUniformLocation(shaderProgram, "time");
GLint lightPosLoc = glGetUniformLocation(shaderProgram, "lightPos");

// Set uniform values
glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model));
glUniformMatrix4fv(viewLoc, 1, GL_FALSE, glm::value_ptr(view));
glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(projection));
glUniform1f(timeLoc, (float)glfwGetTime());
glUniform3f(lightPosLoc, 5.0f, 5.0f, 5.0f);

// Draw using these uniforms
glDrawArrays(GL_TRIANGLES, 0, 36);
```

### Uniform Types and Functions

| GLSL Type | C++ Setter |
|-----------|------------|
| `float` | `glUniform1f(location, value)` |
| `vec2` | `glUniform2f(location, x, y)` |
| `vec3` | `glUniform3f(location, x, y, z)` |
| `vec4` | `glUniform4f(location, x, y, z, w)` |
| `int` | `glUniform1i(location, value)` |
| `ivec2` | `glUniform2i(location, x, y)` |
| `mat3` | `glUniformMatrix3fv(location, count, transpose, value_ptr)` |
| `mat4` | `glUniformMatrix4fv(location, count, transpose, value_ptr)` |
| `sampler2D` | `glUniform1i(location, texture_unit)` |

---

## Part 11: Shader Examples by Effect

### Example 1: Grayscale Filter

```glsl
#version 330 core
in vec2 TexCoord;
out vec4 FragColor;
uniform sampler2D screenTexture;

void main()
{
    vec4 color = texture(screenTexture, TexCoord);
    float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
    FragColor = vec4(gray, gray, gray, color.a);
}
```

### Example 2: Wave Distortion

```glsl
#version 330 core
in vec2 TexCoord;
out vec4 FragColor;
uniform sampler2D texture0;
uniform float time;

void main()
{
    // Distort UV coordinates with sine wave
    vec2 distortedUV = TexCoord;
    distortedUV.x += sin(TexCoord.y * 10.0 + time * 2.0) * 0.02;
    distortedUV.y += cos(TexCoord.x * 10.0 + time * 2.0) * 0.02;
    
    FragColor = texture(texture0, distortedUV);
}
```

### Example 3: Outline Effect

```glsl
#version 330 core
in vec2 TexCoord;
out vec4 FragColor;
uniform sampler2D screenTexture;
uniform vec2 screenSize;

void main()
{
    vec2 pixelSize = 1.0 / screenSize;
    vec4 color = texture(screenTexture, TexCoord);
    
    // Sample neighboring pixels
    float left = texture(screenTexture, TexCoord - vec2(pixelSize.x, 0)).a;
    float right = texture(screenTexture, TexCoord + vec2(pixelSize.x, 0)).a;
    float up = texture(screenTexture, TexCoord + vec2(0, pixelSize.y)).a;
    float down = texture(screenTexture, TexCoord - vec2(0, pixelSize.y)).a;
    
    // If this pixel is transparent but neighbor is opaque, draw outline
    if (color.a < 0.1 && (left > 0.5 || right > 0.5 || up > 0.5 || down > 0.5)) {
        FragColor = vec4(1.0, 1.0, 1.0, 1.0);  // White outline
    } else {
        FragColor = color;
    }
}
```

---

## Part 12: Shader Limitations and Constraints

### What Shaders Cannot Do

| Limitation | Reason |
|------------|--------|
| **Allocate memory** | GPU memory is fixed, pre-allocated |
| **Read arbitrary memory** | Memory access patterns restricted |
| **Write to same memory from multiple threads** | Race conditions, synchronization complex |
| **Recursive function calls** | Stack depth not supported |
| **Dynamic data structures** | No malloc/new on GPU |
| **System calls** | Cannot access files, network, etc. |
| **Persist data between pixels** | Each fragment independent |
| **Know scene context** | Only sees current primitive |

### Performance Constraints

```
GPU HARDWARE LIMITS (typical):
├─ Maximum uniform size: 64KB
├─ Maximum texture units: 16-32
├─ Maximum vertex attributes: 16
├─ Maximum varyings: 32 floats
├─ Maximum instructions: Thousands (shader dependent)
├─ Maximum nested loops: Limited by compiler
└─ Maximum function calls: Inlined, not true calls
```

---

## The 30-Second Summary

- **Shader** = A small program running on the GPU
- **Purpose** = Control every aspect of rendering programmatically
- **Types** = Vertex (per-vertex), Fragment (per-pixel), Geometry, Tessellation, Compute
- **Language** = GLSL (OpenGL Shading Language)
- **Execution** = Thousands of instances in parallel (SIMT model)
- **Input** = Attributes (per-vertex), Uniforms (global), Textures
- **Output** = Transformed vertices (vertex) or colors (fragment)
- **Compilation** = Compiled and linked at runtime like C/C++

**Shaders transformed graphics from hardware-configurable to software-programmable, putting unlimited visual creativity in developers' hands.**

---

