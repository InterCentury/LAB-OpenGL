# What is GLSL? - Beginner's Documentation

## The Musical Score Analogy

GLSL can be understood through a musical score for an orchestra:

- **The Musical Notation** = GLSL language syntax (how to write instructions)
- **The Orchestra** = The GPU (the hardware that performs)
- **The Musicians** = Shader cores (thousands executing in parallel)
- **The Conductor** = The OpenGL driver (interprets and directs)
- **The Sheet Music** = The shader program (instructions for each musician)
- **The Performance** = The rendered graphics (result of execution)

**Just as musical notation tells each musician what to play, GLSL tells each GPU core what to compute. The same score read by different orchestras produces different interpretations - just as GLSL runs on different GPU hardware.**

---

## Part 1: What Actually IS GLSL?

### Definition

**GLSL** (OpenGL Shading Language) is a high-level shading language specifically designed for graphics programming. It is used to write shaders that run directly on the GPU.

### Core Characteristics

| Characteristic | Description |
|----------------|-------------|
| **Full Name** | OpenGL Shading Language |
| **Type** | Domain-specific programming language |
| **Paradigm** | C-like syntax with graphics-specific features |
| **Execution** | Runs on GPU (not CPU) |
| **Introduced** | OpenGL 2.0 (2004) |
| **Current Version** | GLSL 4.60 (matching OpenGL 4.6) |
| **Standardized By** | Khronos Group |

### What Makes GLSL Special

| Feature | Why It Matters |
|---------|----------------|
| **Vector Types** | Native support for math on 2/3/4-component vectors |
| **Matrix Operations** | Built-in matrix multiplication and transformations |
| **Texture Sampling** | Language-level support for fetching texels |
| **Parallel Execution** | Designed for thousands of simultaneous threads |
| **Graphics Pipeline Integration** | Direct mapping to pipeline stages |

---

## Part 2: GLSL Version History

### Version Mapping

| GLSL Version | OpenGL Version | Key Features Added |
|--------------|----------------|-------------------|
| **1.10** | 2.0 | First version, basic shaders |
| **1.20** | 2.1 | More built-in functions |
| **1.30** | 3.0 | Deprecation model introduced |
| **1.40** | 3.1 | Geometry shaders |
| **1.50** | 3.2 | Core profile, tessellation |
| **3.30** | 3.3 | Matched DirectX 10 feature set |
| **4.00** | 4.0 | Tessellation control/evaluation |
| **4.10** | 4.1 | Debugging features |
| **4.20** | 4.2 | Atomic counters, image load/store |
| **4.30** | 4.3 | Compute shaders |
| **4.40** | 4.4 | Buffer queries |
| **4.50** | 4.5 | SPIR-V, Direct State Access |
| **4.60** | 4.6 | SPIR-V consumption, more robust |

### Version Declaration

```glsl
#version 330 core  // OpenGL 3.3, Core Profile

// Common version declarations:
#version 100        // OpenGL ES 2.0
#version 300 es     // OpenGL ES 3.0+
#version 110        // OpenGL 2.0
#version 120        // OpenGL 2.1
#version 130        // OpenGL 3.0
#version 140        // OpenGL 3.1
#version 150        // OpenGL 3.2
#version 330        // OpenGL 3.3
#version 400        // OpenGL 4.0
#version 410        // OpenGL 4.1
#version 420        // OpenGL 4.2
#version 430        // OpenGL 4.3
#version 440        // OpenGL 4.4
#version 450        // OpenGL 4.5
#version 460        // OpenGL 4.6
```

**IMPORTANT:** The version must be the **first line** of the shader, with no comments or whitespace before it.

---

## Part 3: GLSL vs Other Languages

### Comparison with C/C++

| Aspect | C/C++ | GLSL |
|--------|-------|------|
| **Execution** | CPU, sequential | GPU, massively parallel |
| **Memory** | Heap, stack, dynamic allocation | Fixed, pre-allocated only |
| **Function Calls** | Full support | Limited, often inlined |
| **Recursion** | Yes | No |
| **Pointers** | Yes | No (references only) |
| **Standard Library** | Extensive | Graphics-specific functions |
| **Vector Types** | Manual (arrays/structs) | Built-in (vec2/3/4) |
| **Matrix Types** | External libraries | Built-in (mat2/3/4) |
| **Threading** | Manual | Automatic parallelism |

### Comparison with HLSL (DirectX)

| Aspect | GLSL | HLSL |
|--------|------|------|
| **Platform** | OpenGL, Vulkan (via SPIR-V) | DirectX |
| **Syntax** | C-like, more similar to C | C++-like, more features |
| **Compilation** | Online (at runtime) | Online or offline |
| **Standardization** | Khronos Group | Microsoft |
| **Entry Point** | `main()` | `main()` or named functions |
| **Semantics** | Location qualifiers | Semantic strings |

### Comparison with Compute Languages

| Aspect | GLSL | CUDA | OpenCL |
|--------|------|------|--------|
| **Primary Use** | Graphics | General GPU computing | General GPU computing |
| **Graphics Integration** | Native | Limited | Limited |
| **Memory Model** | Pipeline-oriented | General purpose | General purpose |
| **Ease of Learning** | Moderate | Steep | Steep |
| **Vendor** | Khronos | NVIDIA | Khronos |

---

## Part 4: GLSL Language Features

### Type System Highlights

```glsl
// Vectors - the heart of GLSL
vec2 position2D = vec2(1.0, 2.0);
vec3 position3D = vec3(1.0, 2.0, 3.0);
vec4 position4D = vec4(1.0, 2.0, 3.0, 1.0);

// Swizzling - powerful component access
vec3 color = vec3(0.2, 0.4, 0.6);
float red = color.r;           // 0.2
vec2 rg = color.rg;            // (0.2, 0.4)
vec3 bgr = color.bgr;          // (0.6, 0.4, 0.2)
vec4 expanded = color.rrrr;    // (0.2, 0.2, 0.2, 0.2)

// Matrix construction
mat3 rotation = mat3(
    1.0, 0.0, 0.0,  // first column
    0.0, 1.0, 0.0,  // second column
    0.0, 0.0, 1.0   // third column
);

// Arrays (fixed size)
float temperatures[10];
vec3 positions[5];

// Structs
struct Light {
    vec3 position;
    vec3 color;
    float intensity;
    bool enabled;
};

Light light0 = Light(vec3(0.0), vec3(1.0), 1.0, true);
```

### Operator Overloading

GLSL provides intuitive operators for vector/matrix types:

```glsl
vec3 a = vec3(1.0, 2.0, 3.0);
vec3 b = vec3(4.0, 5.0, 6.0);

vec3 sum = a + b;        // (5.0, 7.0, 9.0) - component-wise
vec3 diff = a - b;       // (-3.0, -3.0, -3.0)
vec3 product = a * b;    // (4.0, 10.0, 18.0) - component-wise
vec3 quotient = a / b;   // (0.25, 0.4, 0.5)

// Matrix-vector multiplication
vec3 transformed = rotationMatrix * originalVector;

// Dot and cross products
float dotProduct = dot(a, b);           // 1*4 + 2*5 + 3*6 = 32
vec3 crossProduct = cross(a, b);        // (2*6-3*5, 3*4-1*6, 1*5-2*4)
```

---

## Part 5: Built-in Functions

### Trigonometric Functions

```glsl
float angle = 45.0 * 3.14159 / 180.0;  // Convert to radians

float s = sin(angle);    // Sine
float c = cos(angle);    // Cosine
float t = tan(angle);    // Tangent

float as = asin(0.5);    // Arcsine (returns radians)
float ac = acos(0.5);    // Arccosine
float at = atan(1.0);    // Arctangent

// Hyperbolic
float sh = sinh(angle);  // Hyperbolic sine
float ch = cosh(angle);  // Hyperbolic cosine
float th = tanh(angle);  // Hyperbolic tangent
```

### Exponential Functions

```glsl
float p = pow(2.0, 3.0);      // 8.0 (2^3)
float e = exp(1.0);           // 2.71828 (e^1)
float l = log(2.71828);       // 1.0 (natural log)
float e2 = exp2(3.0);         // 8.0 (2^3)
float l2 = log2(8.0);         // 3.0 (log base 2)

float sq = sqrt(16.0);        // 4.0
float isq = inversesqrt(16.0); // 0.25
```

### Common Functions

```glsl
float a = abs(-5.0);          // 5.0
float s = sign(-5.0);         // -1.0
float f = floor(3.7);         // 3.0
float c = ceil(3.7);          // 4.0
float fr = fract(3.7);        // 0.7 (fractional part)
float m = mod(10.0, 3.0);     // 1.0 (modulo)

float mn = min(5.0, 3.0);     // 3.0
float mx = max(5.0, 3.0);     // 5.0
float cl = clamp(1.5, 0.0, 1.0); // 1.0 (clamp to range)

float mixVal = mix(0.0, 1.0, 0.5); // 0.5 (linear interpolation)
float stepVal = step(0.5, 0.7);    // 1.0 (0.5 threshold, 0.7 >= 0.5)
float smooth = smoothstep(0.0, 1.0, 0.5); // 0.5 (smooth interpolation)
```

### Geometric Functions

```glsl
vec3 v1 = vec3(1.0, 0.0, 0.0);
vec3 v2 = vec3(0.0, 1.0, 0.0);

float len = length(v1);               // 1.0
float dist = distance(v1, v2);        // 1.414 (distance between vectors)
float dotProd = dot(v1, v2);          // 0.0 (perpendicular)
vec3 crossProd = cross(v1, v2);       // (0.0, 0.0, 1.0)

vec3 norm = normalize(vec3(3.0, 4.0, 0.0));  // (0.6, 0.8, 0.0)
vec3 reflectDir = reflect(vec3(0.0, -1.0, 0.0), vec3(0.0, 1.0, 0.0)); // (0.0, 1.0, 0.0)

vec3 incident = vec3(0.0, -1.0, 0.0);
vec3 normal = vec3(0.0, 1.0, 0.0);
vec3 refractDir = refract(incident, normal, 0.8);  // Refraction
```

### Matrix Functions

```glsl
mat4 m = mat4(1.0);  // Identity matrix
mat4 t = transpose(m);
float d = determinant(m);
mat4 inv = inverse(m);  // Expensive, use sparingly

// Matrix component-wise multiplication (not matrix product)
mat4 compMult = matrixCompMult(m1, m2);
```

### Texture Functions

```glsl
// Basic sampling
vec4 color = texture(diffuseMap, texCoord);

// With explicit LOD (Level of Detail)
vec4 color = textureLod(diffuseMap, texCoord, 2.0);

// Gradient sampling (for mipmap selection)
vec4 color = textureGrad(diffuseMap, texCoord, dPdx, dPdy);

// Proj texture (for shadow mapping)
vec4 color = textureProj(shadowMap, vec3(coord, depth));

// Array textures
vec4 color = texture(textureArray, vec3(texCoord, layer));

// Cube maps
vec4 env = texture(cubeMap, directionVector);

// Texel fetch (direct pixel access)
vec4 pixel = texelFetch(image, ivec2(100, 100), 0);
```

---

## Part 6: GLSL Precision Qualifiers

### Precision in Desktop vs Mobile

Desktop OpenGL ignores precision qualifiers, but they're crucial for OpenGL ES.

```glsl
// Precision qualifiers (important for mobile/embedded)
highp vec4 position;     // 32-bit float (highest precision)
mediump vec4 color;      // 16-bit float (good for colors)
lowp float intensity;    // 10-bit fixed point (for quick calculations)

// Default precision declaration (GLSL ES)
precision highp float;
precision mediump int;
```

### When Precision Matters

```glsl
// Position data needs high precision
highp vec3 worldPosition;

// Colors can use medium precision
mediump vec3 diffuseColor;

// Simple flags can use low precision
lowp float alpha;  // 0.0 to 1.0 only

// Setting default precision (OpenGL ES)
#ifdef GL_ES
    precision mediump float;
#endif
```

---

## Part 7: GLSL Interface with OpenGL

### Attribute Locations

```glsl
// GLSL - explicit layout locations
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoord;

// Equivalent C++ code
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, (void*)0);
glEnableVertexAttribArray(0);
```

### Uniform Locations

```glsl
// GLSL uniforms
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
uniform sampler2D diffuseTexture;

// C++ code to set them
GLint modelLoc = glGetUniformLocation(program, "model");
glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model));

// OpenGL 4.3+ - explicit uniform locations
layout (location = 0) uniform mat4 model;
layout (location = 1) uniform mat4 view;
layout (location = 2) uniform sampler2D diffuseTexture;
```

### Uniform Blocks

```glsl
// GLSL - uniform block with std140 layout
layout (std140, binding = 0) uniform Matrices {
    mat4 projection;
    mat4 view;
    vec4 cameraPosition;
    float nearPlane;
    float farPlane;
};

// C++ - matching structure
struct Matrices {
    glm::mat4 projection;
    glm::mat4 view;
    glm::vec4 cameraPosition;
    float nearPlane;
    float farPlane;
    float padding[3];  // For std140 alignment
};
```

---

## Part 8: GLSL Preprocessor

### Preprocessor Directives

```glsl
#version 330 core  // Must be first

// Macros
#define MAX_LIGHTS 4
#define PI 3.14159265359

// Conditional compilation
#ifdef GL_ES
    precision mediump float;
#endif

#if MAX_LIGHTS > 4
    #define COMPLEX_LIGHTING
#endif

// Include (rarely supported)
// #include "common.glsl"  // Not standard!

// Line control
#line 42 "myshader.glsl"

// Error directive
#ifndef REQUIRED_FEATURE
    #error "REQUIRED_FEATURE must be defined"
#endif
```

### Built-in Macros

```glsl
// Version macros
__VERSION__  // GLSL version (e.g., 330)

// Profile detection
__CORE_PROFILE__  // Core profile
__COMPATIBILITY_PROFILE__  // Compatibility profile

// Extension testing
#ifdef GL_ARB_explicit_uniform_location
    // Use explicit uniform locations
#endif
```

---

## Part 9: GLSL Extensions

### Extension System

```glsl
// Enable an extension
#extension GL_ARB_shader_image_load_store : enable

// Require an extension (error if not available)
#extension GL_ARB_shader_atomic_counters : require

// Warn if extension not available
#extension GL_ARB_gpu_shader5 : warn

// Disable an extension
#extension GL_ARB_texture_multisample : disable

// Check extension availability
#ifdef GL_ARB_compute_shader
    // Use compute shader features
#endif
```

### Common Extensions

| Extension | Purpose |
|-----------|---------|
| `GL_ARB_explicit_uniform_location` | Set uniform locations in shader |
| `GL_ARB_shader_image_load_store` | Read/write images in shaders |
| `GL_ARB_shader_atomic_counters` | Atomic operations |
| `GL_ARB_gpu_shader5` | Advanced features like bit operations |
| `GL_ARB_tessellation_shader` | Tessellation support |
| `GL_ARB_compute_shader` | Compute shader support |
| `GL_ARB_shading_language_420pack` | GLSL 4.20 features |

---

## Part 10: GLSL vs SPIR-V

### What is SPIR-V?

**SPIR-V** (Standard Portable Intermediate Representation) is a binary intermediate language for shaders and compute kernels.

```
GLSL (human-readable)
    ↓ [ glslangValidator ]
SPIR-V (binary)
    ↓ [ Driver ]
GPU Machine Code
```

### Advantages of SPIR-V

| Advantage | Description |
|-----------|-------------|
| **Offline Compilation** | Compile once, ship binary |
| **Language Independence** | Can use HLSL, GLSL, or other frontends |
| **Vendor Neutral** | Same binary works across hardware |
| **Security** | Can validate before execution |
| **Load Time** | Faster than compiling from source |

### SPIR-V in OpenGL

OpenGL 4.6 can consume SPIR-V directly:

```cpp
// Load SPIR-V binary
std::ifstream file("shader.spv", std::ios::binary);
std::vector<uint32_t> spirv((std::istreambuf_iterator<char>(file)), {});

// Create shader from SPIR-V
GLuint shader = glCreateShader(GL_VERTEX_SHADER);
glShaderBinary(1, &shader, GL_SHADER_BINARY_FORMAT_SPIR_V, 
               spirv.data(), spirv.size() * sizeof(uint32_t));
glSpecializeShader(shader, "main", 0, nullptr, nullptr);
```

---

## Part 11: Common GLSL Idioms

### Idiom 1: Gamma Correction

```glsl
// sRGB to linear (for texture sampling)
vec3 srgbToLinear(vec3 srgb) {
    return pow(srgb, vec3(2.2));
}

// Linear to sRGB (for framebuffer output)
vec3 linearToSrgb(vec3 linear) {
    return pow(linear, vec3(1.0 / 2.2));
}

void main() {
    vec3 linearColor = srgbToLinear(texture(diffuseMap, texCoord).rgb);
    // Do lighting in linear space
    vec3 lit = calculateLighting(linearColor);
    FragColor = vec4(linearToSrgb(lit), 1.0);
}
```

### Idiom 2: Fresnel Effect

```glsl
// Schlick's approximation
float fresnel(vec3 normal, vec3 viewDir, float f0) {
    float cosTheta = max(dot(normal, viewDir), 0.0);
    return f0 + (1.0 - f0) * pow(1.0 - cosTheta, 5.0);
}

void main() {
    vec3 normal = normalize(vNormal);
    vec3 viewDir = normalize(cameraPos - vFragPos);
    float f0 = 0.04;  // Dielectric base reflectance
    
    float fresnelTerm = fresnel(normal, viewDir, f0);
    // Use fresnelTerm for edge glow
}
```

### Idiom 3: Parallax Mapping

```glsl
vec2 parallaxMapping(vec2 texCoord, vec3 viewDir, sampler2D heightMap) {
    float height = texture(heightMap, texCoord).r;
    vec2 offset = viewDir.xy * (height * 0.1);
    return texCoord - offset;
}

void main() {
    vec3 viewDir = normalize(viewPos - vFragPos);
    vec2 distortedUV = parallaxMapping(vTexCoord, viewDir, heightMap);
    vec4 color = texture(diffuseMap, distortedUV);
}
```

---

## Part 12: Debugging GLSL

### Visual Debugging

```glsl
// 1. Output intermediate values as colors
void main() {
    // Visualize normals
    FragColor = vec4(vNormal * 0.5 + 0.5, 1.0);
    
    // Visualize UV coordinates
    FragColor = vec4(vTexCoord, 0.0, 1.0);
    
    // Visualize world position
    FragColor = vec4(vFragPos * 0.1, 1.0);
    
    // Visualize lighting contribution
    float light = dot(normal, lightDir);
    FragColor = vec4(vec3(light), 1.0);
}
```

### Compilation Debugging

```glsl
// Use #extension to get better error messages
#extension GL_ARB_debug_output : enable

// Add comments with expected values
// Expected: lightDir should be normalized
vec3 lightDir = normalize(lightPos - vFragPos);

// Debug prints (not available in standard GLSL)
// Use RenderDoc or similar tools for runtime debugging
```

### Common Pitfalls

```glsl
// PITFALL 1: Forgetting to normalize interpolated values
vec3 normal = vNormal;  // WRONG - vNormal is interpolated, needs normalization
vec3 normal = normalize(vNormal);  // CORRECT

// PITFALL 2: Matrix multiplication order
gl_Position = vec4(aPos, 1.0) * mvp;  // WRONG - vector * matrix
gl_Position = mvp * vec4(aPos, 1.0);  // CORRECT - matrix * vector

// PITFALL 3: Texture coordinates outside 0-1
FragColor = texture(tex, texCoord * 2.0);  // May clamp to edge

// PITFALL 4: Discarding in wrong context
if (alpha < 0.1) {
    discard;
    color = vec4(1.0);  // UNREACHABLE - discard ends execution
}
```

---

## The 30-Second Summary

- **GLSL** = OpenGL Shading Language, a C-like language for GPU programming
- **Purpose** = Write shaders (vertex, fragment, geometry, tessellation, compute)
- **Key Features** = Vector/matrix types, swizzling, built-in graphics functions
- **Data Types** = vec2/3/4, mat2/3/4, samplers, arrays, structs
- **Built-ins** = Extensive math, geometric, and texture functions
- **Version** = Match with OpenGL version (330 for OpenGL 3.3)
- **Execution** = Massive parallelism on GPU
- **Extensions** = Add functionality beyond core specification

**GLSL is the language of GPU programming in OpenGL - it transforms abstract mathematical concepts into the vibrant pixels displayed on screen.**

---

**Next Step:** Ready to understand the complete graphics pipeline with all shader stages?